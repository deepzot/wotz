<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript" src="http://mbostock.github.com/d3/d3.js?1.29.1"></script>
    <style type="text/css">

body {
  background: gray;
}

    </style>
  </head>
  <body>
    <script type="text/javascript">


var w = 500,
    h = 400,
    nBaddies = 5,
    degrees = 180 / Math.PI;

// Container
var svg = d3.select("body").append("svg:svg")
    .attr("width", w)
    .attr("height", h)
    
// Draw boarders, background stuff
var borders = svg.selectAll('line')
	.data([[0,0,w,0],[0,0,0,h],[w,0,w,h],[0,h,w,h]])
.enter().append("svg:line")
	.style("stroke","black")
	.attr("x1",function(d){ return d[0]; })
	.attr("y1",function(d){ return d[1]; })
	.attr("x2",function(d){ return d[2]; })
	.attr("y2",function(d){ return d[3]; });
	
// Draw our home
var home = svg.append('g');
var homeRect = home.selectAll('rect')
		.data([{path:[w/2,h/2],w:10,h:10}])
	.enter()
		.append('svg:rect');
homeRect
		.attr("transform", function(d) { return "translate(" + (d.path[0] - d.w/2) + ',' + (d.path[1] - d.h/2) + ")"; })
		.attr("width", function(d) { return d.w; } )
		.attr("height", function(d) { return d.h; } )
		.attr("fill","yellow");
		
// Create Fired shots array and svg group
var firedShots = [];

// Create some random baddies
createRandomBaddie = function() {
	var x = Math.random() * w, y = Math.random() * h;
  return {
    vx: Math.random() - .5,
    vy: Math.random() - .5,
    path: [x, y],
  };
}
var randomBaddies = d3.range(nBaddies).map(createRandomBaddie);

// The heartbeat
d3.timer(function() {
	// Update baddie positions
  for (var i = 0; i < randomBaddies.length; i++) {
    var randomBaddie = randomBaddies[i],
        path = randomBaddie.path,
        dx = randomBaddie.vx,
        dy = randomBaddie.vy,
        x = path[0] += dx,
        y = path[1] += dy;

    // Wrap around the walls.
    if (x < 0 || x > w) path[0] = Math.abs(w - x);
    if (y < 0 || y > h) path[1] = Math.abs(h - y);
	}
	// Update fired shots and detect collisions with baddies
  for (var i = 0; i < firedShots.length; i++) {
    var shot = firedShots[i],
        path = shot.path,
        dx = shot.vx,
        dy = shot.vy,
        x = path[0] += dx,
        y = path[1] += dy;

    // Remove when we get to a wall
    if (x < 0 || x > w) {firedShots.splice(i,1); i--; continue;}
    if (y < 0 || y > h) {firedShots.splice(i,1); i--; continue;}
    
    // Collision detection
    for (var j = 0; j < randomBaddies.length; j++) {
    	var randomBaddie = randomBaddies[j],
    			baddieX = randomBaddie.path[0],
    			baddieY = randomBaddie.path[1];
    	// *** hardcoded baddieRadius+shotRadius ** FIXME
			if(isCollision({x:x,y:y},{x:baddieX,y:baddieY},6)){
				// Remove baddie and shot
				randomBaddies.splice(j,1);
				j--;
				firedShots.splice(i,1);
				i--;
				continue;
			}
		}	
	}
	// Update svg elements
	redraw();
});

// Listen for keydown events
d3.select(window).on("keydown", function() {
		var keyCode = d3.event.keyCode;
		if(keyCode == 32) {
			randomBaddies.push(createRandomBaddie());
		}
});

// Listen for mouse click events
svg.on("mousedown", function(d) {
	// Get mouse x,y coordinates relative to svg container
	var path = d3.mouse(this);
	// Calculate angle relative to origin at home
	var origin = [w/2,h/2];
	var theta = Math.atan2(path[1] - origin[1], path[0] - origin[0]);
	// Calculate velocity
	var speed = 2;
	var vx = speed*Math.cos(theta), vy = speed*Math.sin(theta);
	// Add shot to the list of shotsfired
	var shot = {path:origin, vx:vx, vy:vy};
	firedShots.push(shot);
});


redraw = function() {
	// Update baddies
	var baddies = svg.selectAll("ellipse.baddies")
		.data(randomBaddies);
	baddies.enter().append("svg:ellipse")
		.attr('class','baddies')
    .attr("rx", 4.5)
    .attr("ry", 3.5)
    .style('fill','white');
  baddies.attr("transform", function(d) {
    return "translate(" + d.path + ")rotate(" + Math.atan2(d.vy, d.vx) * degrees + ")";
  });
	baddies.exit()
		.remove();	
	// Update fired shots
	var shots = svg.selectAll('circle.shots')
		.data(firedShots);
	shots.enter().append('svg:circle')
		.attr('class','shots')
		.attr("r",2)
		.attr('fill','blue');
	shots
		.attr("transform", function(d) { return "translate(" + d.path + ")" });
	shots.exit()
		.remove();
};

// Returns true if point and pos are within a distrance r of each other
isCollision = function(point,pos,r) {
	var dx = point.x - pos.x;
	var dy = point.y - pos.y;
	var dist = Math.sqrt(dx * dx + dy * dy);
	if( dist <= r ){
		return true;
	}
	return false;
};

    </script>
  </body>
</html>